#include <iostream>
#include <vector>
#include <limits>
#include <queue>
#include <algorithm>
#include <stack>
#include "graph.h" // Assuming you have a Graph class defined in graph.h

using namespace std;

// Greedy Chinese Postman Algorithm

void ChinesePostman::findShortestRouteGreedy() {
    // Step 1: Find all odd degree vertices
    vector<int> oddVertices = findOddDegreeVertices();

    // Step 2: Find the shortest path between all pairs of odd degree vertices
    vector<vector<int>> shortestPaths = findShortestPaths(oddVertices);

    // Step 3: Find the minimum weight perfect matching
    vector<pair<int, int>> matching = findMinimumWeightMatching(shortestPaths, oddVertices);

    // Step 4: Add the matching edges to the graph
    addMatchingEdgesToGraph(matching, shortestPaths, oddVertices);

    // Step 5: Find Eulerian circuit
    vector<int> eulerianCircuit = findEulerianCircuit();

    // Step 6: Split the Eulerian circuit among the postmen
    vector<vector<int>> routes = splitCircuitAmongPostmen(eulerianCircuit);

    // Print the routes
    printRoutes(routes);
}

vector<int> ChinesePostman::findOddDegreeVertices() {
    vector<int> oddVertices;
    int vertices = graph.getVertices();
    const auto& adjMatrix = graph.getAdjMatrix();

    for (int i = 0; i < vertices; ++i) {
        int degree = 0;
        for (int j = 0; j < vertices; ++j) {
            if (adjMatrix[i][j] > 0) {
                degree++;
            }
        }
        if (degree % 2 != 0) {
            oddVertices.push_back(i);
        }
    }
    return oddVertices;
}

vector<vector<int>> ChinesePostman::findShortestPaths(const vector<int>& oddVertices) {
    int n = oddVertices.size();
    vector<vector<int>> shortestPaths(n, vector<int>(n, numeric_limits<int>::max()));
    int vertices = graph.getVertices();
    const auto& adjMatrix = graph.getAdjMatrix();

    auto bfs = [&](int start) {
        vector<int> distances(vertices, numeric_limits<int>::max());
        queue<int> q;
        q.push(start);
        distances[start] = 0;

        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (int v = 0; v < vertices; ++v) {
                if (adjMatrix[u][v] > 0 && distances[v] == numeric_limits<int>::max()) {
                    distances[v] = distances[u] + 1;
                    q.push(v);
                }
            }
        }
        return distances;
    };

    for (int i = 0; i < n; ++i) {
        vector<int> distances = bfs(oddVertices[i]);
        for (int j = 0; j < n; ++j) {
            shortestPaths[i][j] = distances[oddVertices[j]];
        }
    }
    return shortestPaths;
}

vector<pair<int, int>> ChinesePostman::findMinimumWeightMatching(const vector<vector<int>>& shortestPaths, const vector<int>& oddVertices) {
    vector<pair<int, int>> matching;
    int n = shortestPaths.size();
    vector<bool> matched(n, false);

    for (int i = 0; i < n; ++i) {
        if (matched[i]) continue;
        int bestMatch = -1;
        int bestWeight = numeric_limits<int>::max();

        for (int j = 0; j < n; ++j) {
            if (i != j && !matched[j] && shortestPaths[i][j] < bestWeight) {
                bestWeight = shortestPaths[i][j];
                bestMatch = j;
            }
        }

        if (bestMatch != -1) {
            matching.emplace_back(oddVertices[i], oddVertices[bestMatch]);
            matched[i] = matched[bestMatch] = true;
        }
    }
    return matching;
}

void ChinesePostman::addMatchingEdgesToGraph(const vector<pair<int, int>>& matching, const vector<vector<int>>& shortestPaths, const vector<int>& oddVertices) {
    for (const auto& edge : matching) {
        graph.addEdge(edge.first, edge.second);
    }
}

vector<int> ChinesePostman::findEulerianCircuit() {
    vector<int> circuit;
    const auto& adjMatrix = graph.getAdjMatrix();
    int vertices = graph.getVertices();
    vector<vector<int>> tempMatrix = adjMatrix;

    stack<int> stack;
    stack.push(0);

    while (!stack.empty()) {
        int u = stack.top();
        bool foundEdge = false;

        for (int v = 0; v < vertices; ++v) {
            if (tempMatrix[u][v] > 0) {
                stack.push(v);
                tempMatrix[u][v]--;
                tempMatrix[v][u]--;
                foundEdge = true;
                break;
            }
        }

        if (!foundEdge) {
            circuit.push_back(u);
            stack.pop();
        }
    }
    return circuit;
}

vector<vector<int>> ChinesePostman::splitCircuitAmongPostmen(const vector<int>& eulerianCircuit) {
    vector<vector<int>> routes(numPostmen);
    int circuitSize = eulerianCircuit.size();
    int routeSize = circuitSize / numPostmen;

    for (int i = 0; i < numPostmen; ++i) {
        for (int j = 0; j < routeSize; ++j) {
            routes[i].push_back(eulerianCircuit[(i * routeSize + j) % circuitSize]);
        }
    }
    return routes;
}

void ChinesePostman::printRoutes(const vector<vector<int>>& routes) {
    for (int i = 0; i < routes.size(); ++i) {
        cout << "Route for postman " << i + 1 << ": ";
        for (int vertex : routes[i]) {
            cout << vertex << " ";
        }
        cout << endl;
    }
}


// Exact Chinese Postman Algorithm

vector<int> ChinesePostman::findOddDegreeVerticesExact() {
    return findOddDegreeVertices(); // Same logic as in the greedy version
}

vector<vector<int>> ChinesePostman::findShortestPathsExact(const vector<int>& oddVertices) {
    return findShortestPaths(oddVertices); // Same logic as in the greedy version
}

vector<pair<int, int>> ChinesePostman::findMinimumCostPerfectMatchingExact(const vector<vector<int>>& shortestPaths, const vector<int>& oddVertices) {
    int n = shortestPaths.size();
    vector<pair<int, int>> matching;

    // Dynamic programming (bitmask) to solve the matching
    vector<int> dp(1 << n, numeric_limits<int>::max());
    vector<int> parent(1 << n, -1);
    dp[0] = 0;

    for (int mask = 0; mask < (1 << n); ++mask) {
        for (int i = 0; i < n; ++i) {
            if (mask & (1 << i)) {
                for (int j = i + 1; j < n; ++j) {
                    if (mask & (1 << j)) {
                        int newMask = mask ^ (1 << i) ^ (1 << j);
                        int cost = dp[newMask] + shortestPaths[i][j];
                        if (cost < dp[mask]) {
                            dp[mask] = cost;
                            parent[mask] = (i << 16) | j;
                        }
                    }
                }
            }
        }
    }

    int mask = (1 << n) - 1;
    while (parent[mask] != -1) {
        int pairData = parent[mask];
        int i = (pairData >> 16) & 0xFFFF;
        int j = pairData & 0xFFFF;
        matching.emplace_back(oddVertices[i], oddVertices[j]);
        mask ^= (1 << i) ^ (1 << j);
    }

    return matching;
}

void ChinesePostman::addMatchingEdgesToGraphExact(const vector<pair<int, int>>& matching) {
    for (const auto& edge : matching) {
        graph.addEdge(edge.first, edge.second);
    }
}

vector<int> ChinesePostman::findEulerianCircuitExact() {
    return findEulerianCircuit(); // Same logic as in the greedy version
}

vector<vector<int>> ChinesePostman::splitCircuitAmongPostmenExact(const vector<int>& eulerianCircuit) {
    return splitCircuitAmongPostmen(eulerianCircuit); // Same logic as in the greedy version
}

void ChinesePostman::printRoutesExact(const vector<vector<int>>& routes) {
    printRoutes(routes); // Same logic as in the greedy version
}








void ChinesePostman::findShortestRouteExact() {

    // Step 1: Find all odd degree vertices
    vector<int> oddVertices = findOddDegreeVerticesExact();

    // Step 2: Find the shortest path between all pairs of odd degree vertices
    vector<vector<int>> shortestPaths = findShortestPathsExact(oddVertices);

    // Step 3: Solve Minimum-Cost Perfect Matching problem using exact algorithm
    vector<pair<int, int>> matching = findMinimumCostPerfectMatchingExact(shortestPaths, oddVertices);

    // Step 4: Add the matching edges to the graph
    addMatchingEdgesToGraphExact(matching);

    // Step 5: Find Eulerian circuit
    vector<int> eulerianCircuit = findEulerianCircuitExact();

    // Step 6: Split the Eulerian circuit among the postmen
    vector<vector<int>> routes = splitCircuitAmongPostmenExact(eulerianCircuit);

    // Print the routes
    printRoutesExact(routes);
}


++ *.o -o main -lm -lsfml-graphics -lsfml-window -lsfml-system
/usr/bin/ld: Postman.o: in function `ChinesePostman::findOddDegreeVertices()':
Postman.cpp:(.text+0x1ba): multiple definition of `ChinesePostman::findOddDegreeVertices()'; greedyPostman.o:greedyPostman.cpp:(.text+0x1ba): first defined here
/usr/bin/ld: Postman.o: in function `ChinesePostman::findShortestPaths(std::vector<int, std::allocator<int> > const&)':
Postman.cpp:(.text+0x558): multiple definition of `ChinesePostman::findShortestPaths(std::vector<int, std::allocator<int> > const&)'; greedyPostman.o:greedyPostman.cpp:(.text+0x558): first defined here
/usr/bin/ld: Postman.o: in function `ChinesePostman::findMinimumWeightMatching(std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > const&, std::vector<int, std::allocator<int> > const&)':
Postman.cpp:(.text+0x7a0): multiple definition of `ChinesePostman::findMinimumWeightMatching(std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > const&, std::vector<int, std::allocator<int> > const&)'; greedyPostman.o:greedyPostman.cpp:(.text+0x7a0): first defined here
/usr/bin/ld: Postman.o: in function `ChinesePostman::addMatchingEdgesToGraph(std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > > const&, std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > const&, std::vector<int, std::allocator<int> > const&)':
Postman.cpp:(.text+0xa88): multiple definition of `ChinesePostman::addMatchingEdgesToGraph(std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > > const&, std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > const&, std::vector<int, std::allocator<int> > const&)'; greedyPostman.o:greedyPostman.cpp:(.text+0xa88): first defined here
/usr/bin/ld: Postman.o: in function `ChinesePostman::findEulerianCircuit()':
Postman.cpp:(.text+0xb42): multiple definition of `ChinesePostman::findEulerianCircuit()'; greedyPostman.o:greedyPostman.cpp:(.text+0xb42): first defined here
/usr/bin/ld: Postman.o: in function `ChinesePostman::splitCircuitAmongPostmen(std::vector<int, std::allocator<int> > const&)':
Postman.cpp:(.text+0xdee): multiple definition of `ChinesePostman::splitCircuitAmongPostmen(std::vector<int, std::allocator<int> > const&)'; greedyPostman.o:greedyPostman.cpp:(.text+0xdee): first defined here
/usr/bin/ld: Postman.o: in function `ChinesePostman::printRoutes(std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > const&)':
Postman.cpp:(.text+0xf5a): multiple definition of `ChinesePostman::printRoutes(std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > const&)'; greedyPostman.o:greedyPostman.cpp:(.text+0xf5a): first defined here
/usr/bin/ld: Postman.o: in function `ChinesePostman::findOddDegreeVerticesExact()':
Postman.cpp:(.text+0x10b8): multiple definition of `ChinesePostman::findOddDegreeVerticesExact()'; exactPostman.o:exactPostman.cpp:(.text+0x1aa): first defined here
/usr/bin/ld: Postman.o: in function `ChinesePostman::findShortestPathsExact(std::vector<int, std::allocator<int> > const&)':
Postman.cpp:(.text+0x1104): multiple definition of `ChinesePostman::findShortestPathsExact(std::vector<int, std::allocator<int> > const&)'; exactPostman.o:exactPostman.cpp:(.text+0x2ee): first defined here
/usr/bin/ld: Postman.o: in function `ChinesePostman::findMinimumCostPerfectMatchingExact(std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > const&, std::vector<int, std::allocator<int> > const&)':
Postman.cpp:(.text+0x1158): multiple definition of `ChinesePostman::findMinimumCostPerfectMatchingExact(std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > const&, std::vector<int, std::allocator<int> > const&)'; exactPostman.o:exactPostman.cpp:(.text+0x6ec): first defined here
/usr/bin/ld: Postman.o: in function `ChinesePostman::addMatchingEdgesToGraphExact(std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > > const&)':
Postman.cpp:(.text+0x1578): multiple definition of `ChinesePostman::addMatchingEdgesToGraphExact(std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > > const&)'; exactPostman.o:exactPostman.cpp:(.text+0xb0c): first defined here
/usr/bin/ld: Postman.o: in function `ChinesePostman::findEulerianCircuitExact()':
Postman.cpp:(.text+0x162a): multiple definition of `ChinesePostman::findEulerianCircuitExact()'; exactPostman.o:exactPostman.cpp:(.text+0xbbe): first defined here
/usr/bin/ld: Postman.o: in function `ChinesePostman::splitCircuitAmongPostmenExact(std::vector<int, std::allocator<int> > const&)':
Postman.cpp:(.text+0x1676): multiple definition of `ChinesePostman::splitCircuitAmongPostmenExact(std::vector<int, std::allocator<int> > const&)'; exactPostman.o:exactPostman.cpp:(.text+0xbe0): first defined here
/usr/bin/ld: Postman.o: in function `ChinesePostman::printRoutesExact(std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > const&)':
Postman.cpp:(.text+0x16ca): multiple definition of `ChinesePostman::printRoutesExact(std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > const&)'; exactPostman.o:exactPostman.cpp:(.text+0xc06): first defined here
/usr/bin/ld: Postman.o: in function `ChinesePostman::findShortestRouteExact()':
Postman.cpp:(.text+0x16f0): multiple definition of `ChinesePostman::findShortestRouteExact()'; exactPostman.o:exactPostman.cpp:(.text+0x0): first defined here
collect2: error: ld returned 1 exit status
make: *** [Makefile:3: compile] Error 1


how would you fix this postman.cpp file