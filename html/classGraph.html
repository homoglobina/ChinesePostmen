<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Problem chinskich listonoszy: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Problem chinskich listonoszy<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classGraph.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classGraph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a75f2fb8a2597472026295c7ca4b6da36" id="r_a75f2fb8a2597472026295c7ca4b6da36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75f2fb8a2597472026295c7ca4b6da36">Graph</a> (int v, double satruation)</td></tr>
<tr class="memdesc:a75f2fb8a2597472026295c7ca4b6da36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classGraph.html">Graph</a> object with a specified number of vertices and edge saturation.  <br /></td></tr>
<tr class="separator:a75f2fb8a2597472026295c7ca4b6da36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791d8e647a9efed98b379af82f1f88ff" id="r_a791d8e647a9efed98b379af82f1f88ff"><td class="memItemLeft" align="right" valign="top"><a id="a791d8e647a9efed98b379af82f1f88ff" name="a791d8e647a9efed98b379af82f1f88ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Graph</b> (const std::string &amp;jsonFile)</td></tr>
<tr class="separator:a791d8e647a9efed98b379af82f1f88ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c10df34357b2cd865c81e0c4f0bd8c" id="r_ad8c10df34357b2cd865c81e0c4f0bd8c"><td class="memItemLeft" align="right" valign="top"><a id="ad8c10df34357b2cd865c81e0c4f0bd8c" name="ad8c10df34357b2cd865c81e0c4f0bd8c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addEdge</b> (int u, int v)</td></tr>
<tr class="separator:ad8c10df34357b2cd865c81e0c4f0bd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad845c0a17f997ed1995e8272900d7388" id="r_ad845c0a17f997ed1995e8272900d7388"><td class="memItemLeft" align="right" valign="top"><a id="ad845c0a17f997ed1995e8272900d7388" name="ad845c0a17f997ed1995e8272900d7388"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getVertices</b> () const</td></tr>
<tr class="separator:ad845c0a17f997ed1995e8272900d7388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459fe77c0d6bcb9001d6deb560609c0b" id="r_a459fe77c0d6bcb9001d6deb560609c0b"><td class="memItemLeft" align="right" valign="top"><a id="a459fe77c0d6bcb9001d6deb560609c0b" name="a459fe77c0d6bcb9001d6deb560609c0b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getEdges</b> () const</td></tr>
<tr class="separator:a459fe77c0d6bcb9001d6deb560609c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ef0236b26294dfe550378fd1561cc8" id="r_a67ef0236b26294dfe550378fd1561cc8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67ef0236b26294dfe550378fd1561cc8">getOddDegreeVertices</a> () const</td></tr>
<tr class="memdesc:a67ef0236b26294dfe550378fd1561cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vertices with odd degrees in the graph.  <br /></td></tr>
<tr class="separator:a67ef0236b26294dfe550378fd1561cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e88a40742c8f19a22bbd4abaaa084fc" id="r_a4e88a40742c8f19a22bbd4abaaa084fc"><td class="memItemLeft" align="right" valign="top"><a id="a4e88a40742c8f19a22bbd4abaaa084fc" name="a4e88a40742c8f19a22bbd4abaaa084fc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getEdgeWeight</b> (int u, int v) const</td></tr>
<tr class="separator:a4e88a40742c8f19a22bbd4abaaa084fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25aa6d47d56005a0e7dfa457036e3dd7" id="r_a25aa6d47d56005a0e7dfa457036e3dd7"><td class="memItemLeft" align="right" valign="top"><a id="a25aa6d47d56005a0e7dfa457036e3dd7" name="a25aa6d47d56005a0e7dfa457036e3dd7"></a>
const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAdjMatrix</b> () const</td></tr>
<tr class="separator:a25aa6d47d56005a0e7dfa457036e3dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058b7780e6fea9077a1a825357fe713d" id="r_a058b7780e6fea9077a1a825357fe713d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a058b7780e6fea9077a1a825357fe713d">isEulerian</a> () const</td></tr>
<tr class="memdesc:a058b7780e6fea9077a1a825357fe713d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the graph is Eulerian.  <br /></td></tr>
<tr class="separator:a058b7780e6fea9077a1a825357fe713d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9af916770c65c6b60b582ffc563d8ed" id="r_ae9af916770c65c6b60b582ffc563d8ed"><td class="memItemLeft" align="right" valign="top"><a id="ae9af916770c65c6b60b582ffc563d8ed" name="ae9af916770c65c6b60b582ffc563d8ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printAdjMatrix</b> ()</td></tr>
<tr class="separator:ae9af916770c65c6b60b582ffc563d8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74e06c10ca4208e6e47e4b13ae21ecc" id="r_ac74e06c10ca4208e6e47e4b13ae21ecc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac74e06c10ca4208e6e47e4b13ae21ecc">toGraphviz</a> (const std::string &amp;filename) const</td></tr>
<tr class="memdesc:ac74e06c10ca4208e6e47e4b13ae21ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports the graph to a Graphviz DOT format file.  <br /></td></tr>
<tr class="separator:ac74e06c10ca4208e6e47e4b13ae21ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086df5448819fd063526ade35df2d1e3" id="r_a086df5448819fd063526ade35df2d1e3"><td class="memItemLeft" align="right" valign="top"><a id="a086df5448819fd063526ade35df2d1e3" name="a086df5448819fd063526ade35df2d1e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setSeed</b> (int seed)</td></tr>
<tr class="separator:a086df5448819fd063526ade35df2d1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc5928fcb92abb8093c3f4164f66270" id="r_a0cc5928fcb92abb8093c3f4164f66270"><td class="memItemLeft" align="right" valign="top"><a id="a0cc5928fcb92abb8093c3f4164f66270" name="a0cc5928fcb92abb8093c3f4164f66270"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getSeed</b> () const</td></tr>
<tr class="separator:a0cc5928fcb92abb8093c3f4164f66270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc88f6e084ef824b55402e31a028694" id="r_abfc88f6e084ef824b55402e31a028694"><td class="memItemLeft" align="right" valign="top"><a id="abfc88f6e084ef824b55402e31a028694" name="abfc88f6e084ef824b55402e31a028694"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>solveChinesePostman</b> (int n)</td></tr>
<tr class="separator:abfc88f6e084ef824b55402e31a028694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454b34173c9f088a2e12ab8bd6ca4868" id="r_a454b34173c9f088a2e12ab8bd6ca4868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a454b34173c9f088a2e12ab8bd6ca4868">makeGraphEulerian</a> ()</td></tr>
<tr class="memdesc:a454b34173c9f088a2e12ab8bd6ca4868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the graph to an Eulerian graph by adding the minimum number of edges.  <br /></td></tr>
<tr class="separator:a454b34173c9f088a2e12ab8bd6ca4868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc6976cffea1b252b2b884fb5b74f4a" id="r_a2dc6976cffea1b252b2b884fb5b74f4a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dc6976cffea1b252b2b884fb5b74f4a">findEulerCycle</a> ()</td></tr>
<tr class="memdesc:a2dc6976cffea1b252b2b884fb5b74f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an Eulerian cycle in the graph.  <br /></td></tr>
<tr class="separator:a2dc6976cffea1b252b2b884fb5b74f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e49d8a89ea6c617eba36691d9201782" id="r_a9e49d8a89ea6c617eba36691d9201782"><td class="memItemLeft" align="right" valign="top"><a id="a9e49d8a89ea6c617eba36691d9201782" name="a9e49d8a89ea6c617eba36691d9201782"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>calculateCycleCost</b> (const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;cycle)</td></tr>
<tr class="separator:a9e49d8a89ea6c617eba36691d9201782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c9f5ed9520b198507ae3b3951d500c" id="r_a30c9f5ed9520b198507ae3b3951d500c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30c9f5ed9520b198507ae3b3951d500c">findEuler</a> ()</td></tr>
<tr class="memdesc:a30c9f5ed9520b198507ae3b3951d500c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an Eulerian cycle in the graph.  <br /></td></tr>
<tr class="separator:a30c9f5ed9520b198507ae3b3951d500c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbade69a4ba279e19cfc26f82cdb1b0" id="r_a1dbade69a4ba279e19cfc26f82cdb1b0"><td class="memItemLeft" align="right" valign="top"><a id="a1dbade69a4ba279e19cfc26f82cdb1b0" name="a1dbade69a4ba279e19cfc26f82cdb1b0"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dijkstra</b> (int start)</td></tr>
<tr class="separator:a1dbade69a4ba279e19cfc26f82cdb1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5e1c59e6e72aa4f17654acb65550e5" id="r_a7d5e1c59e6e72aa4f17654acb65550e5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d5e1c59e6e72aa4f17654acb65550e5">reconstructShortestPath</a> (int start, int end, const std::vector&lt; int &gt; &amp;dist)</td></tr>
<tr class="memdesc:a7d5e1c59e6e72aa4f17654acb65550e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs the shortest path from start to end using the distance vector.  <br /></td></tr>
<tr class="separator:a7d5e1c59e6e72aa4f17654acb65550e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cf39561e4b72830374f4bb8ec2d8f0" id="r_a63cf39561e4b72830374f4bb8ec2d8f0"><td class="memItemLeft" align="right" valign="top"><a id="a63cf39561e4b72830374f4bb8ec2d8f0" name="a63cf39561e4b72830374f4bb8ec2d8f0"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>shuffeledVertices</b> (int vertices)</td></tr>
<tr class="separator:a63cf39561e4b72830374f4bb8ec2d8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f4dc092d064375ad0b22ed4b067470" id="r_ac6f4dc092d064375ad0b22ed4b067470"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6f4dc092d064375ad0b22ed4b067470">solveGenetic</a> (int n, int x)</td></tr>
<tr class="memdesc:ac6f4dc092d064375ad0b22ed4b067470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Chinese Postman Problem using a genetic algorithm.  <br /></td></tr>
<tr class="separator:ac6f4dc092d064375ad0b22ed4b067470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1511ec4f314019fc6e030ab03388e29f" id="r_a1511ec4f314019fc6e030ab03388e29f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1511ec4f314019fc6e030ab03388e29f">findBestPopulations</a> (std::vector&lt; float &gt; &amp;fitnessScores, std::vector&lt; std::vector&lt; std::vector&lt; int &gt; &gt; &gt; &amp;populations, int n)</td></tr>
<tr class="memdesc:a1511ec4f314019fc6e030ab03388e29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the best and second best populations based on their fitness scores.  <br /></td></tr>
<tr class="separator:a1511ec4f314019fc6e030ab03388e29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080f4cda4b4c847d1015bdb672326936" id="r_a080f4cda4b4c847d1015bdb672326936"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a080f4cda4b4c847d1015bdb672326936">testFitness</a> (std::vector&lt; std::vector&lt; int &gt; &gt; route)</td></tr>
<tr class="memdesc:a080f4cda4b4c847d1015bdb672326936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the fitness of a given set of routes in the graph.  <br /></td></tr>
<tr class="separator:a080f4cda4b4c847d1015bdb672326936"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a75f2fb8a2597472026295c7ca4b6da36" name="a75f2fb8a2597472026295c7ca4b6da36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f2fb8a2597472026295c7ca4b6da36">&#9670;&#160;</a></span>Graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>saturation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="classGraph.html">Graph</a> object with a specified number of vertices and edge saturation. </p>
<p>This constructor initializes a graph with a given number of vertices and a specified saturation level. The saturation level determines the proportion of possible edges that will be present in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The number of vertices in the graph. </td></tr>
    <tr><td class="paramname">saturation</td><td>The saturation level of the graph, a value between 0 and 1 representing the proportion of edges. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1511ec4f314019fc6e030ab03388e29f" name="a1511ec4f314019fc6e030ab03388e29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1511ec4f314019fc6e030ab03388e29f">&#9670;&#160;</a></span>findBestPopulations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; int, int &gt; Graph::findBestPopulations </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fitnessScores</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; int &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>populations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the best and second best populations based on their fitness scores. </p>
<p>This function identifies the populations with the highest and second highest fitness scores from the given fitness scores and populations. It prints the fitness scores and the routes of the best and second best populations for each postman.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fitnessScores</td><td>A vector of fitness scores for each population. </td></tr>
    <tr><td class="paramname">populations</td><td>A vector of populations, where each population is a vector of routes, and each route is a vector of vertices. </td></tr>
    <tr><td class="paramname">n</td><td>The number of postmen (routes) in each population. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of integers representing the indices of the best and second best populations. </dd></dl>

</div>
</div>
<a id="a30c9f5ed9520b198507ae3b3951d500c" name="a30c9f5ed9520b198507ae3b3951d500c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c9f5ed9520b198507ae3b3951d500c">&#9670;&#160;</a></span>findEuler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; int, int &gt; &gt; Graph::findEuler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an Eulerian cycle in the graph. </p>
<p>This function uses Fleury's algorithm to find an Eulerian cycle in the graph. An Eulerian cycle is a cycle that visits every edge exactly once.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of pairs representing the Eulerian cycle. Each pair contains a vertex and -1, indicating the traversal of the cycle. </dd></dl>

</div>
</div>
<a id="a2dc6976cffea1b252b2b884fb5b74f4a" name="a2dc6976cffea1b252b2b884fb5b74f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc6976cffea1b252b2b884fb5b74f4a">&#9670;&#160;</a></span>findEulerCycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int, int &gt; &gt; Graph::findEulerCycle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an Eulerian cycle in the graph. </p>
<p>This function uses Hierholzer's algorithm to find an Eulerian cycle in the graph. An Eulerian cycle is a cycle that visits every edge exactly once.</p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::pair&lt;int, int&gt;&gt; A vector of pairs representing the edges in the Eulerian cycle. Each pair contains two integers representing the vertices connected by the edge. </dd></dl>

</div>
</div>
<a id="a67ef0236b26294dfe550378fd1561cc8" name="a67ef0236b26294dfe550378fd1561cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ef0236b26294dfe550378fd1561cc8">&#9670;&#160;</a></span>getOddDegreeVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; int, int &gt; &gt; Graph::getOddDegreeVertices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the vertices with odd degrees in the graph. </p>
<p>This function iterates through all vertices in the graph and calculates the degree of each vertex. If a vertex has an odd degree, it is added to the list of odd degree vertices.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of pairs, where each pair contains a vertex index and its degree, for all vertices with odd degrees. </dd></dl>

</div>
</div>
<a id="a058b7780e6fea9077a1a825357fe713d" name="a058b7780e6fea9077a1a825357fe713d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058b7780e6fea9077a1a825357fe713d">&#9670;&#160;</a></span>isEulerian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::isEulerian </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the graph is Eulerian. </p>
<p>An Eulerian graph is a graph in which all vertices have an even degree. This function iterates through all vertices and checks their degrees. If any vertex has an odd degree, the graph is not Eulerian.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the graph is Eulerian, false otherwise. </dd></dl>

</div>
</div>
<a id="a454b34173c9f088a2e12ab8bd6ca4868" name="a454b34173c9f088a2e12ab8bd6ca4868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454b34173c9f088a2e12ab8bd6ca4868">&#9670;&#160;</a></span>makeGraphEulerian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::makeGraphEulerian </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the graph to an Eulerian graph by adding the minimum number of edges. </p>
<p>This function modifies the graph to make it Eulerian by ensuring all vertices have even degrees. It identifies vertices with odd degrees and pairs them up by adding edges with the minimum cost.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the number of vertices with odd degrees is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d5e1c59e6e72aa4f17654acb65550e5" name="a7d5e1c59e6e72aa4f17654acb65550e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5e1c59e6e72aa4f17654acb65550e5">&#9670;&#160;</a></span>reconstructShortestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; Graph::reconstructShortestPath </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dist</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconstructs the shortest path from start to end using the distance vector. </p>
<p>This function takes the start and end vertices along with the distance vector and reconstructs the shortest path from start to end by backtracking through the adjacency matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting vertex of the path. </td></tr>
    <tr><td class="paramname">end</td><td>The ending vertex of the path. </td></tr>
    <tr><td class="paramname">dist</td><td>The distance vector containing the shortest distances from the start vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the vertices in the shortest path from start to end. </dd></dl>

</div>
</div>
<a id="ac6f4dc092d064375ad0b22ed4b067470" name="ac6f4dc092d064375ad0b22ed4b067470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f4dc092d064375ad0b22ed4b067470">&#9670;&#160;</a></span>solveGenetic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::solveGenetic </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Chinese Postman Problem using a genetic algorithm. </p>
<p>This function attempts to find an optimal solution for the Chinese Postman Problem by simulating a genetic algorithm over a specified number of generations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of postmen. </td></tr>
    <tr><td class="paramname">x</td><td>The number of generations.</td></tr>
  </table>
  </dd>
</dl>
<p>The function performs the following steps:</p><ol type="1">
<li>Shuffles the vertices and selects starting points for each postman.</li>
<li>Creates an initial population of possible solutions.</li>
<li>Evaluates the fitness of the initial population.</li>
<li>Iteratively generates new populations through crossover and mutation, selecting the best population based on fitness.</li>
<li>Prints the fitness and routes of the first and last generations.</li>
<li>Calculates and prints the accuracy and correctness of the final solution.</li>
<li>Saves the results to a JSON file.</li>
</ol>
<p>The fitness of a population is evaluated using the <code>testFitness</code> function. The population is evolved using the <code>createPopulation</code>, <code>crossover</code>, and <code>mutate</code> functions. The final results are saved to a file named "resultsGenetic.json". </p>

</div>
</div>
<a id="a080f4cda4b4c847d1015bdb672326936" name="a080f4cda4b4c847d1015bdb672326936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080f4cda4b4c847d1015bdb672326936">&#9670;&#160;</a></span>testFitness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Graph::testFitness </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>route</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the fitness of a given set of routes in the graph. </p>
<p>This function evaluates the fitness of a set of routes based on the adjacency matrix of the graph. The fitness is calculated by summing the weights of the edges used in the routes, penalizing for missing edges, route imbalance, and excessive total route length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">route</td><td>A vector of vectors representing the routes. Each inner vector contains the sequence of nodes in a route. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fitness value of the given routes. Higher values indicate better fitness. </dd></dl>

</div>
</div>
<a id="ac74e06c10ca4208e6e47e4b13ae21ecc" name="ac74e06c10ca4208e6e47e4b13ae21ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74e06c10ca4208e6e47e4b13ae21ecc">&#9670;&#160;</a></span>toGraphviz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::toGraphviz </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports the graph to a Graphviz DOT format file. </p>
<p>This function generates a Graphviz DOT format representation of the graph and writes it to the specified file. Each edge in the graph is assigned a random color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to which the Graphviz DOT format will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>programs/OK/ChinesePostmen/src/<a class="el" href="graph_8h_source.html">graph.h</a></li>
<li>programs/OK/ChinesePostmen/src/<a class="el" href="djikstra_8cpp.html">djikstra.cpp</a></li>
<li>programs/OK/ChinesePostmen/src/<b>geneticc.cpp</b></li>
<li>programs/OK/ChinesePostmen/src/<a class="el" href="graph_8cpp.html">graph.cpp</a></li>
<li>programs/OK/ChinesePostmen/src/<b>postman.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classGraph.html">Graph</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
