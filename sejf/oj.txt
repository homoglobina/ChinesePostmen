#include "graphRendering.h"

    GraphRendering renderer(graph);
    renderer.renderTraversal({{0, 1, 2, 3, 4, 5, 0}, {1, 3, 4, 2, 1}});


Postman

std::vector<std::tuple<int, int, int>> Postman::findPairings(const std::vector<std::pair<int, int>>& oddVertices) const {
    std::vector<std::tuple<int, int, int>> pairings;
    for (size_t i = 0; i < oddVertices.size(); ++i) {
        for (size_t j = i + 1; j < oddVertices.size(); ++j) {
            int weight = graph.findShortestPath(oddVertices[i].first, oddVertices[j].first);
            pairings.emplace_back(oddVertices[i].first, oddVertices[j].first, weight);
        }
    }
    std::sort(pairings.begin(), pairings.end(), [](const auto& a, const auto& b) {
        return std::get<2>(a) < std::get<2>(b);
    });
    return pairings;
}

void Postman::distributeRoutes(const std::vector<std::tuple<int, int, int>>& pairings) {
    int totalWeight = 0;
    for (const auto& [u, v, weight] : pairings) {
        totalWeight += weight;
        std::cout << "Pairing: " << u << " -> " << v << " with weight " << weight << std::endl;
    }
    std::cout << "Total additional weight for odd degree pairing: " << totalWeight << std::endl;
}

void Postman::solve() {
    auto oddVertices = graph.getOddDegreeVertices();
    if (oddVertices.empty()) {
        std::cout << "No odd degree vertices. The graph is already Eulerian!" << std::endl;
        return;
    }
    auto pairings = findPairings(oddVertices);
    distributeRoutes(pairings);
}


    std::vector<std::tuple<int, int, int>> findPairings(const std::vector<std::pair<int, int>>& oddVertices) const;
    void distributeRoutes(const std::vector<std::tuple<int, int, int>>& pairings);
